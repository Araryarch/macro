"C Competitive": {
  "prefix": "ccomp",
  "body": [
    "#include <stdio.h>",
    "#include <stdlib.h>",
    "#include <string.h>",
    "#include <math.h>",
    "#include <stdbool.h>",
    "#include <limits.h>",
    "#include <ctype.h>",
    "#include <regex.h>",
    "",
    "// Logging",
    "#define log(msg) printf(\"%s\\n\", msg)",
    "#define logf(format, ...) printf(format \"\\n\", __VA_ARGS__)",
    "#define logError(msg) fprintf(stderr, \"%s\\n\", msg)",
    "#define assert(condition, msg) if (!(condition)) { logError(msg); exit(1); }",
    "",
    "// Array methods",
    "#define length(arr) (sizeof(arr) / sizeof(*(arr)))",
    "#define forEach(arr, func) for (int i = 0; i < length(arr); i++) { func((arr)[i]); }",
    "#define map(arr, func, result) for (int i = 0; i < length(arr); i++) { (result)[i] = func((arr)[i]); }",
    "#define filter(arr, func, result) ({ \\",
    "    int j = 0; \\",
    "    for (int i = 0; i < length(arr); i++) { \\",
    "        if (func((arr)[i])) (result)[j++] = (arr)[i]; \\",
    "    } \\",
    "    result + j; \\",
    "})",
    "#define reduce(arr, func, initial) ({ typeof(initial) acc = initial; for (int i = 0; i < length(arr); i++) { acc = func(acc, (arr)[i]); } acc; })",
    "#define includes(arr, value) ({ bool found = false; for (int i = 0; i < length(arr); i++) if ((arr)[i] == value) { found = true; break; } found; })",
    "#define reverse(arr) for (int i = 0; i < length(arr) / 2; i++) { typeof((arr)[0]) temp = (arr)[i]; (arr)[i] = (arr)[length(arr) - 1 - i]; (arr)[length(arr) - 1 - i] = temp; }",
    "#define sortAsc(arr, cmp) qsort(arr, length(arr), sizeof((arr)[0]), cmp)",
    "#define sortDesc(arr, cmp) qsort(arr, length(arr), sizeof((arr)[0]), cmp)",
    "#define unique(arr, result) ({ \\",
    "    int j = 0; \\",
    "    for (int i = 0; i < length(arr); i++) { \\",
    "        if (!includes(result, (arr)[i])) (result)[j++] = (arr)[i]; \\",
    "    } \\",
    "    result + j; \\",
    "})",
    "#define push(arr, value) (*(arr)++ = (value))",
    "#define pop(arr) (arr > (typeof(arr))arr ? *--arr : (typeof(*arr))0)",
    "#define shift(arr) ({ \\",
    "    typeof(*arr) first = arr[0]; \\",
    "    memmove(arr, arr + 1, (length(arr) - 1) * sizeof(*arr)); \\",
    "    *(arr + length(arr) - 1) = (typeof(*arr))0; \\",
    "    first; \\",
    "})",
    "#define unshift(arr, value) ({ \\",
    "    memmove(arr + 1, arr, length(arr) * sizeof(*arr)); \\",
    "    arr[0] = value; \\",
    "    arr + 1; \\",
    "})",
    "",
    "// String methods",
    "#define startsWith(str, prefix) (strncmp(str, prefix, strlen(prefix)) == 0)",
    "#define endsWith(str, suffix) ({ int l1 = strlen(str); int l2 = strlen(suffix); (l1 >= l2 && strcmp(str + l1 - l2, suffix) == 0); })",
    "#define toUpperCase(str) for (char *s = str; *s; s++) *s = toupper((unsigned char)*s)",
    "#define toLowerCase(str) for (char *s = str; *s; s++) *s = tolower((unsigned char)*s)",
    "#define trim(str) ({ char *end; while (isspace((unsigned char)*str)) str++; if (*str == 0) str; else { end = str + strlen(str) - 1; while (end > str && isspace((unsigned char)*end)) end--; end[1] = '\\0'; str; } })",
    "#define regexReplace(str, pattern, replacement, result) ({ \\",
    "    regex_t regex; \\",
    "    regcomp(&regex, pattern, REG_EXTENDED); \\",
    "    regmatch_t match; \\",
    "    char buffer[1024]; \\",
    "    strcpy(result, str); \\",
    "    while (regexec(&regex, result, 1, &match, 0) == 0) { \\",
    "        strncpy(buffer, result, match.rm_so); \\",
    "        buffer[match.rm_so] = '\\0'; \\",
    "        strcat(buffer, replacement); \\",
    "        strcat(buffer, result + match.rm_eo); \\",
    "        strcpy(result, buffer); \\",
    "    } \\",
    "    regfree(&regex); \\",
    "})",
    "#define regexMatch(str, pattern) ({ \\",
    "    regex_t regex; \\",
    "    regcomp(&regex, pattern, REG_EXTENDED); \\",
    "    int res = regexec(&regex, str, 0, NULL, 0); \\",
    "    regfree(&regex); \\",
    "    res == 0; \\",
    "})",
    "#define regexDeleteWhitespace(str, result) regexReplace(str, \"\\\\s+\", \"\", result)",
    "#define split(str, delimiter, result, result_len) { char *token = strtok(str, delimiter); int i = 0; while (token != NULL) { (result)[i++] = token; token = strtok(NULL, delimiter); } *(result_len) = i; }",
    "#define join(arr, delimiter, result) { strcpy(result, (arr)[0]); for (int i = 1; i < length(arr); i++) { strcat(result, delimiter); strcat(result, (arr)[i]); } }",
    "#define repeat(str, n, result) { result[0] = '\\0'; for (int i = 0; i < n; i++) strcat(result, str); }",
    "#define replace(str, from, to, result) { char *pos = strstr(str, from); if (pos != NULL) { strncpy(result, str, pos - str); result[pos - str] = '\\0'; strcat(result, to); strcat(result, pos + strlen(from)); } else strcpy(result, str); }",
    "#define substring(str, start, len) (strndup(str + start, len))",
    "",
    "// Math utilities",
    "#define max(a, b) ((a) > (b) ? (a) : (b))",
    "#define min(a, b) ((a) < (b) ? (a) : (b))",
    "#define abs(n) ((n) < 0 ? -(n) : (n))",
    "#define ceil(n) ((int)((n) + 0.5))",
    "#define floor(n) ((int)(n))",
    "#define round(n) ((int)((n) + 0.5))",
    "#define random(min, max) ((min) + rand() % ((max) - (min) + 1))",
    "#define clamp(n, minVal, maxVal) (max(minVal, min(n, maxVal)))",
    "#define gcd(a, b) ({ int _a = (a), _b = (b); while (_b != 0) { int t = _b; _b = _a % _b; _a = t; } _a; })",
    "#define lcm(a, b) ((a) * (b) / gcd(a, b))",
    "",
    "// Bitwise operations",
    "#define andBits(x, y) ((x) & (y))",
    "#define orBits(x, y) ((x) | (y))",
    "#define xorBits(x, y) ((x) ^ (y))",
    "#define notBits(x) (~(x))",
    "#define shiftLeft(x, n) ((x) << (n))",
    "#define shiftRight(x, n) ((x) >> (n))",
    "#define toggleBit(x, n) ((x) ^ (1 << (n)))",
    "#define checkBit(x, n) (!!((x) & (1 << (n))))",
    "#define setBit(x, n) ((x) | (1 << (n)))",
    "#define clearBit(x, n) ((x) & ~(1 << (n)))",
    "#define countSetBits(x) ({ int count = 0; for (int i = 0; i < sizeof(x) * 8; i++) if ((x) & (1 << i)) count++; count; })",
    "",
    "// Swap two values",
    "#define swap(a, b) do { typeof(a) temp = a; a = b; b = temp; } while (0)",
    "",
    "// Memoization helper",
    "#define memoize(func, arg, memo) ({ \\",
    "    static typeof(func(arg)) memo[1000] = {0}; \\",
    "    static bool calculated[1000] = {false}; \\",
    "    if (!calculated[arg]) { \\",
    "        memo[arg] = func(arg); \\",
    "        calculated[arg] = true; \\",
    "    } \\",
    "    memo[arg]; \\",
    "})",
    "",
    "// Quick sort",
    "#define quickSort(arr, low, high) ({ \\",
    "    if (low < high) { \\",
    "        typeof(*arr) pivot = arr[high]; \\",
    "        int i = (low - 1); \\",
    "        for (int j = low; j <= high - 1; j++) { \\",
    "            if (arr[j] < pivot) { \\",
    "                i++; \\",
    "                typeof(*arr) temp = arr[i]; \\",
    "                arr[i] = arr[j]; \\",
    "                arr[j] = temp; \\",
    "            } \\",
    "        } \\",
    "        typeof(*arr) temp = arr[i + 1]; \\",
    "        arr[i + 1] = arr[high]; \\",
    "        arr[high] = temp; \\",
    "        int pi = i + 1; \\",
    "        quickSort(arr, low, pi - 1); \\",
    "        quickSort(arr, pi + 1, high); \\",
    "    } \\",
    "})",
    "",
    "// Merge for merge sort",
    "#define merge(arr, l, m, r) ({ \\",
    "    int i, j, k; \\",
    "    int n1 = m - l + 1; \\",
    "    int n2 = r - m; \\",
    "    typeof(*arr) L[n1], R[n2]; \\",
    "    for (i = 0; i < n1; i++) L[i] = arr[l + i]; \\",
    "    for (j = 0; j < n2; j++) R[j] = arr[m + 1 + j]; \\",
    "    i = 0; j = 0; k = l; \\",
    "    while (i < n1 && j < n2) { \\",
    "        if (L[i] <= R[j]) arr[k] = L[i++]; \\",
    "        else arr[k] = R[j++]; \\",
    "        k++; \\",
    "    } \\",
    "    while (i < n1) arr[k++] = L[i++]; \\",
    "    while (j < n2) arr[k++] = R[j++]; \\",
    "})",
    "",
    "// Merge sort",
    "#define mergeSort(arr, l, r) ({ \\",
    "    if (l < r) { \\",
    "        int m = l + (r - l) / 2; \\",
    "        mergeSort(arr, l, m); \\",
    "        mergeSort(arr, m + 1, r); \\",
    "        merge(arr, l, m, r); \\",
    "    } \\",
    "})",
    "",
    "// Binary search",
    "#define binarySearch(arr, n, x) ({ \\",
    "    int l = 0, r = n - 1; \\",
    "    while (l <= r) { \\",
    "        int m = l + (r - l) / 2; \\",
    "        if (arr[m] == x) return m; \\",
    "        if (arr[m] < x) l = m + 1; \\",
    "        else r = m - 1; \\",
    "    } \\",
    "    -1; \\",
    "})",
    "",
    "// Fibonacci with memoization",
    "#define fibonacci(n) memoize(fibonacci, n, fib_memo)",
    "",
    "// Prime factorization",
    "#define primeFactors(n, factors) ({ \\",
    "    typeof(*factors) *ptr = factors; \\",
    "    while (n % 2 == 0) { \\",
    "        *ptr++ = 2; \\",
    "        n = n / 2; \\",
    "    } \\",
    "    for (int i = 3; i <= sqrt(n); i += 2) { \\",
    "        while (n % i == 0) { \\",
    "            *ptr++ = i; \\",
    "            n = n / i; \\",
    "        } \\",
    "    } \\",
    "    if (n > 2) *ptr++ = n; \\",
    "    ptr; \\",
    "})",
    "",
    "// Sieve of Eratosthenes",
    "#define sieveOfEratosthenes(n, prime) ({ \\",
    "    memset(prime, true, sizeof(prime)); \\",
    "    for (int p = 2; p * p <= n; p++) { \\",
    "        if (prime[p] == true) { \\",
    "            for (int i = p * p; i <= n; i += p) \\",
    "                prime[i] = false; \\",
    "        } \\",
    "    } \\",
    "})",
    "",
    "// Power with modulo",
    "#define powerMod(x, y, m) ({ \\",
    "    long long res = 1; \\",
    "    x = x % m; \\",
    "    while (y > 0) { \\",
    "        if (y & 1) res = (res * x) % m; \\",
    "        y = y >> 1; \\",
    "        x = (x * x) % m; \\",
    "    } \\",
    "    res; \\",
    "})",
    "",
    "// Compute LPS array for KMP",
    "#define computeLPSArray(pat, M, lps) ({ \\",
    "    int len = 0; \\",
    "    lps[0] = 0; \\",
    "    int i = 1; \\",
    "    while (i < M) { \\",
    "        if (pat[i] == pat[len]) { \\",
    "            len++; \\",
    "            lps[i] = len; \\",
    "            i++; \\",
    "        } else { \\",
    "            if (len != 0) { \\",
    "                len = lps[len - 1]; \\",
    "            } else { \\",
    "                lps[i] = 0; \\",
    "                i++; \\",
    "            } \\",
    "        } \\",
    "    } \\",
    "})",
    "",
    "// KMP Search",
    "#define KMPSearch(pat, txt) ({ \\",
    "    int M = strlen(pat); \\",
    "    int N = strlen(txt); \\",
    "    int lps[M]; \\",
    "    computeLPSArray(pat, M, lps); \\",
    "    int i = 0; \\",
    "    int j = 0; \\",
    "    while (i < N) { \\",
    "        if (pat[j] == txt[i]) { \\",
    "            j++; \\",
    "            i++; \\",
    "        } \\",
    "        if (j == M) { \\",
    "            printf(\"Found pattern at index %d \\n\", i - j); \\",
    "            j = lps[j - 1]; \\",
    "        } else if (i < N && pat[j] != txt[i]) { \\",
    "            if (j != 0) \\",
    "                j = lps[j - 1]; \\",
    "            else \\",
    "                i = i + 1; \\",
    "        } \\",
    "    } \\",
    "})",
    "",
    "// Example usage in main function",
    "int main() {",
    "    return 0;",
    "}"
  ],
  "description": "C Competitive"
}