{
  "C++ Competitive Programming Snippets": {
    "scope": "c++, cpp",
    "prefix": "cppcomp",
    "body": [
      "#include <bits/stdc++.h>",
      "using namespace std;",
      "#define int long long",
      "#define log(msg) (std::cout << msg << std::endl)",
      "#define logError(msg) (std::cerr << msg << std::endl)",
      "#define throwError(msg) (throw std::runtime_error(msg))",
      "#define assert(condition, msg) if (!(condition)) throwError(msg)",
      "",
      "// Array methods (JavaScript-like)",
      "#define forEach(arr, func) for (auto& item : arr) { func(item); }",
      "#define map(arr, func) ({ std::vector<decltype(func(arr[0]))> _result; for (auto& item : arr) { _result.push_back(func(item)); } _result; })",
      "#define filter(arr, func) ({ std::vector<decltype(arr[0])> _result; for (auto& item : arr) { if (func(item)) _result.push_back(item); } _result; })",
      "#define reduce(arr, func, initial) ({ auto _acc = initial; for (auto& item : arr) { _acc = func(_acc, item); } _acc; })",
      "#define some(arr, func) (std::any_of(arr.begin(), arr.end(), func))",
      "#define every(arr, func) (std::all_of(arr.begin(), arr.end(), func))",
      "#define includes(arr, value) (std::find(arr.begin(), arr.end(), value) != arr.end())",
      "#define concat(arr1, arr2) (arr1.insert(arr1.end(), arr2.begin(), arr2.end()))",
      "#define slice(arr, start, end) (std::vector<decltype(arr[0])>(arr.begin() + start, arr.begin() + end))",
      "#define indexOf(arr, value) (std::find(arr.begin(), arr.end(), value) - arr.begin())",
      "#define find(arr, func) ({ auto it = std::find_if(arr.begin(), arr.end(), func); (it != arr.end() ? *it : -1); })",
      "#define fill(arr, value) (std::fill(arr.begin(), arr.end(), value))",
      "#define reverse(arr) (std::reverse(arr.begin(), arr.end()))",
      "#define sortAsc(arr) (std::sort(arr.begin(), arr.end()))",
      "#define sortDesc(arr) (std::sort(arr.rbegin(), arr.rend()))",
      "#define unique(arr) ({ std::sort(arr.begin(), arr.end()); arr.erase(std::unique(arr.begin(), arr.end()), arr.end()); })",
      "#define push(arr, value) (arr.push_back(value))",
      "#define pop(arr) (arr.pop_back())",
      "#define shift(arr) (arr.erase(arr.begin()))",
      "#define unshift(arr, value) (arr.insert(arr.begin(), value))",
      "",
      "// String methods",
      "#define startsWith(str, prefix) (str.rfind(prefix, 0) == 0)",
      "#define endsWith(str, suffix) (str.size() >= suffix.size() && 0 == str.compare(str.size()-suffix.size(), suffix.size(), suffix))",
      "#define toUpperCase(str) (std::transform(str.begin(), str.end(), str.begin(), ::toupper))",
      "#define toLowerCase(str) (std::transform(str.begin(), str.end(), str.begin(), ::tolower))",
      "#define split(str, delimiter) ({ std::vector<std::string> _result; std::string token; std::istringstream tokenStream(str); while (std::getline(tokenStream, token, delimiter)) { _result.push_back(token); } _result; })",
      "#define join(arr, delimiter) ({ std::ostringstream os; for (int i = 0; i < arr.size(); ++i) { if (i) os << delimiter; os << arr[i]; } os.str(); })",
      "#define repeat(str, n) ({ std::string _result; for (int i = 0; i < n; ++i) _result += str; _result; })",
      "#define trim(str) ({ auto start = str.find_first_not_of(' '); auto end = str.find_last_not_of(' '); str.substr(start, end - start + 1); })",
      "#define replace(str, from, to) ({ size_t start_pos = str.find(from); if(start_pos != std::string::npos) str.replace(start_pos, from.length(), to); str; })",
      "#define substring(str, start, len) (str.substr(start, len))",
      "#define length(str) (str.length())",
      "",
      "// Math utilities",
      "#define max(a, b) (a > b ? a : b)",
      "#define min(a, b) (a < b ? a : b)",
      "#define pow(base, exp) (std::pow(base, exp))",
      "#define sqrt(n) (std::sqrt(n))",
      "#define abs(n) (std::abs(n))",
      "#define ceil(n) (std::ceil(n))",
      "#define floor(n) (std::floor(n))",
      "#define round(n) (std::round(n))",
      "#define random(min, max) (min + rand() % (max - min + 1))",
      "#define clamp(n, minVal, maxVal) (std::max(minVal, std::min(n, maxVal)))",
      "#define gcd(a, b) (std::gcd(a, b))",
      "#define lcm(a, b) ((a * b) / gcd(a, b))",
      "",
      "// Bitwise operations",
      "#define andBits(x, y) (x & y)",
      "#define orBits(x, y) (x | y)",
      "#define xorBits(x, y) (x ^ y)",
      "#define notBits(x) (~x)",
      "#define shiftLeft(x, n) (x << n)",
      "#define shiftRight(x, n) (x >> n)",
      "",
      "// Set and Map utilities",
      "#define setAdd(s, val) (s.insert(val))",
      "#define setDelete(s, val) (s.erase(val))",
      "#define setHas(s, val) (s.find(val) != s.end())",
      "#define setSize(s) (s.size())",
      "#define mapSet(m, key, value) (m[key] = value)",
      "#define mapGet(m, key) (m[key])",
      "#define mapHas(m, key) (m.find(key) != m.end())",
      "#define mapDelete(m, key) (m.erase(key))",
      "#define mapSize(m) (m.size())",
      "",
      "// Time utilities",
      "#define now() (std::chrono::system_clock::now())",
      "#define sleep(ms) (std::this_thread::sleep_for(std::chrono::milliseconds(ms)))",
      "#define duration(start, end) (std::chrono::duration_cast<std::chrono::milliseconds>(end - start).count())",
      "",
      "// Sorting and Searching algorithms",
      "#define binarySearch(arr, value) (std::binary_search(arr.begin(), arr.end(), value))",
      "#define lowerBound(arr, value) (std::lower_bound(arr.begin(), arr.end(), value) - arr.begin())",
      "#define upperBound(arr, value) (std::upper_bound(arr.begin(), arr.end(), value) - arr.begin())",
      "#define nextPermutation(arr) (std::next_permutation(arr.begin(), arr.end()))",
      "#define prevPermutation(arr) (std::prev_permutation(arr.begin(), arr.end()))",
      "",
      "// Graph utilities",
      "#define addEdge(adj, u, v) (adj[u].push_back(v))",
      "#define addEdgeWeighted(adj, u, v, w) (adj[u].push_back({v, w}))",
      "#define dfs(adj, v, visited, func) ({ visited[v] = true; func(v); for (auto& u : adj[v]) if (!visited[u]) dfs(adj, u, visited, func); })",
      "#define bfs(adj, v, func) ({ std::queue<int> q; std::vector<bool> visited(adj.size(), false); q.push(v); visited[v] = true; while (!q.empty()) { int u = q.front(); q.pop(); func(u); for (auto& w : adj[u]) if (!visited[w]) { q.push(w); visited[w] = true; } } })",
      "#define dijkstra(adj, src, dist) ({ std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<std::pair<int, int>>> pq; pq.push({0, src}); dist[src] = 0; while (!pq.empty()) { int u = pq.top().second; pq.pop(); for (auto& [v, weight] : adj[u]) { if (dist[u] + weight < dist[v]) { dist[v] = dist[u] + weight; pq.push({dist[v], v}); } } } })",
      "",
      "// Miscellaneous",
      "#define isEven(n) (n % 2 == 0)",
      "#define isOdd(n) (n % 2 != 0)",
      "#define swap(a, b) (std::swap(a, b))",
      "#define repeat(n, func) for (int i = 0; i < n; i++) func()",
      "#define range(start, end) (std::vector<int>(std::iota(start, end)))",
      "#define print(arr) (for (auto& item : arr) std::cout << item << ' '; std::cout << std::endl)",
      "",
      "int main() {",
      "  $1",
      "  return 0;",
      "}"
    ],
    "description": "Competitive Programming with JavaScript-like macros"
  }
}
